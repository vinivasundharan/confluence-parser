<table data-layout="default" ac:local-id="97918d97-8571-451a-b101-78b010e79395"><colgroup><col style="width: 340.0px;" /><col style="width: 340.0px;" /></colgroup><tbody><tr><th data-highlight-colour="#f0f0f0"><p><strong>Reviewers:</strong></p></th><td><p /></td></tr><tr><th data-highlight-colour="#f0f0f0"><p><strong>Authors:</strong></p></th><td><p><ac:link><ri:user ri:account-id="64106a102cee496759e9f6b6" /></ac:link> </p></td></tr><tr><th data-highlight-colour="#f0f0f0"><p><strong>Status:</strong></p></th><td><p><strong><span style="color: rgb(255,255,255);">D</span></strong> <ac:structured-macro ac:name="status" ac:schema-version="1" ac:macro-id="2ff642fe-a764-45b8-ab65-6c9448a3975a"><ac:parameter ac:name="title">Discussion</ac:parameter><ac:parameter ac:name="colour">Yellow</ac:parameter></ac:structured-macro> <ac:structured-macro ac:name="status" ac:schema-version="1" ac:macro-id="55927e68-12be-401e-a961-362d9eeda671"><ac:parameter ac:name="title">active</ac:parameter><ac:parameter ac:name="colour">Green</ac:parameter></ac:structured-macro>  </p></td></tr><tr><th data-highlight-colour="#f0f0f0"><p><strong>Revisions:</strong></p></th><td><p /></td></tr><tr><th data-highlight-colour="#f0f0f0"><p><strong>Due Date:</strong></p></th><td><p><time datetime="2023-07-17" /> </p></td></tr></tbody></table><ac:structured-macro ac:name="toc" ac:schema-version="1" data-layout="default" ac:local-id="f039ca60-21d2-44f6-93af-6266f7dc9d07" ac:macro-id="23b992ec-ad35-4d25-afb4-b3838693d029"><ac:parameter ac:name="minLevel">1</ac:parameter><ac:parameter ac:name="maxLevel">6</ac:parameter><ac:parameter ac:name="outline">false</ac:parameter><ac:parameter ac:name="type">list</ac:parameter><ac:parameter ac:name="separator">brackets</ac:parameter><ac:parameter ac:name="printable">false</ac:parameter></ac:structured-macro><h2>Overview:</h2><p><em>Centraized manifest repository provides a location to store, version control and manage the deployment manifests or configuration files for Kubernetes. This repository can act as the single source of truth for the K8 manifests when it comes to helm deployments. In the case of kustomize, this would be the base with overlays of different combinations and applications pulling this base.</em></p><h2>Goals and Non-Goals:</h2><p>Goals: </p><ul><li><p><em>How can a centralized manifest repo fit in the current Getir setup with minimal changes. </em></p></li><li><p><em>How to leverage Helm and/or Kustomize to the best </em></p></li></ul><p>Non-Goal:</p><ul><li><p><em>How the setup would fit in the CD solution.</em></p></li></ul><h2>Background &amp; Motivation:</h2><p><em>Currently, the manifest repos are located in each application separately which makes it very difficult to change the base templates version or introduce mandatory configurations, annotations, and labels for the K8 deployments. </em></p><p>Developers can also find it difficult to use the best practices in kustomize or Helm.</p><p><em>Terms: GitOps, Helm, Kustomize</em></p><ac:structured-macro ac:name="info" ac:schema-version="1" ac:macro-id="35c644b4-ad9c-472c-ab1c-3e6e99257b16"><ac:rich-text-body><p>Relevant links (If you are skim reader like me, feel free to navigate through the links to get the overall picture <ac:emoticon ac:name="smile" ac:emoji-shortname=":slight_smile:" ac:emoji-id="1f642" ac:emoji-fallback="ðŸ™‚" /> )</p><p><a href="https://bitbucket.org/getirdev/kustomize-base-manifests/src/poc-helm-centralized-repo/" data-card-appearance="inline">https://bitbucket.org/getirdev/kustomize-base-manifests/src/poc-helm-centralized-repo/</a> - helm</p><p><a href="https://bitbucket.org/getirdev/kustomize-base-manifests/src/poc-kustomize-centralized-repo/" data-card-appearance="inline">https://bitbucket.org/getirdev/kustomize-base-manifests/src/poc-kustomize-centralized-repo/</a> - kustomize </p><p><a href="https://bitbucket.org/getirdev/piebot-manifests/src/poc-kustomize-centralized-repo/" data-card-appearance="inline">https://bitbucket.org/getirdev/piebot-manifests/src/poc-kustomize-centralized-repo/</a> - example</p><p><a href="https://argocd-dev.tower.getirapi.com/applications/argocd-dev/piebot-helm-way?view=tree&amp;resource=">Helm deployment on argocd</a></p><p><a href="https://argocd-dev.tower.getirapi.com/applications/argocd-dev/piebot-kustomize-way?view=tree&amp;resource=">Kustomize deployment on argocd</a></p><p><a href="https://eu-west-1.console.aws.amazon.com/ecr/repositories/private/289722705324/getir-app?region=eu-west-1">Helm chart registry</a></p></ac:rich-text-body></ac:structured-macro><h2>Design:</h2><p>The base manifest repo should be separate from the application repo and the platform team should own the manifest to leverage the best knowledge of the tools. </p><p>The solution would also involve if we want to use helm or kustomize. </p><h3>Using Helm</h3><ac:structured-macro ac:name="info" ac:schema-version="1" ac:macro-id="773e7dd2-0c9a-4fea-8056-25086fef8d88"><ac:rich-text-body><p>Helm is a package manager for Kubernetes that allows you to define, install, and manage applications as Helm charts. A Helm chart is a collection of Kubernetes manifests (YAML files) that describe the resources required to deploy a particular application.</p></ac:rich-text-body></ac:structured-macro><p>Proposed structure: </p><ac:structured-macro ac:name="code" ac:schema-version="1" ac:macro-id="33a9f89e-c33b-41ee-932d-6e8622bc45a5"><ac:plain-text-body><![CDATA[BASE REPOSITORY

|__Helm_template_repository
|____ Chart.yaml
|____ values.default.yaml
|____ templates
|_______ deployment.yaml
|_______ hpa.yaml
|_______ service.yaml

APPLICATION REPOSITORY

|__app_manifest_repository
|____ Chart.yaml 
|____ values.default.override.yaml
|____ dev
|_______ values.dev.yaml
|_______ secrets.dev.yaml
|____ prod
|_______ values.prod.yaml
|_______ secrets.prod.yaml

]]></ac:plain-text-body></ac:structured-macro><ac:structured-macro ac:name="info" ac:schema-version="1" ac:macro-id="a845d55b-46c7-4769-a758-e0417b3fa757"><ac:rich-text-body><p>Manifest repo: <a href="https://bitbucket.org/getirdev/kustomize-base-manifests/src/poc-helm-centralized-repo/manifest/" data-card-appearance="inline">https://bitbucket.org/getirdev/kustomize-base-manifests/src/poc-helm-centralized-repo/manifest/</a> </p><p>Application repo: <a href="https://bitbucket.org/getirdev/kustomize-base-manifests/src/poc-helm-centralized-repo/test-microservice/chart/" data-card-appearance="inline">https://bitbucket.org/getirdev/kustomize-base-manifests/src/poc-helm-centralized-repo/test-microservice/chart/</a> </p><p>The results of the templating can be found on the results folder</p></ac:rich-text-body></ac:structured-macro><p>By separating the Base Repository from the Application Repository, we can maintain a centralized source of truth for the base Helm chart while allowing applications to customize and extend the chart based on their specific needs. This structure promotes reusability, consistency, and efficient management of deployments across multiple applications or environments.</p><p>The helm chart can be pushed to a private chart-museum or ECR (AWS supports using ECR as helm registry)</p><p>We could use kustomize on top of helm charts and manipulate the manifest with overlay patches (Example below)</p><table data-layout="default" ac:local-id="7303124a-37d4-47aa-80a6-b3f31d6fd44d"><tbody><tr><th><p><strong>Pros</strong></p></th><th><p><strong>Cons</strong></p></th></tr><tr><td><p>Easy for developers to manipulate values.yaml files, no knowledge of Kubernetes manifest required</p></td><td><p>Using a private helm registry is not very easy when it comes to using them as dependency chart. </p></td></tr><tr><td><p>Versioning is very easy and would be backward compatible as all helm charts versions would be saved</p></td><td><p>Creating the template which would fit all the options used in the applications can be some effort</p></td></tr><tr><td><p>Helm rollbacks are very easy without any 3rd party tools. </p></td><td><p /></td></tr><tr><td><p /></td><td><p /></td></tr></tbody></table><h3>Using Kustomize</h3><ac:structured-macro ac:name="info" ac:schema-version="1" ac:macro-id="ca4a635d-6b98-4c81-9f6a-a16e807a85f3"><ac:rich-text-body><p>Kustomize is a native configuration management tool for Kubernetes that allows you to customize and manage Kubernetes manifests using overlays and patches. With Kustomize, you can define base manifests and then apply overlays to modify or extend them based on different environments or requirements.</p></ac:rich-text-body></ac:structured-macro><p>Proposed Structure: </p><ac:structured-macro ac:name="code" ac:schema-version="1" ac:macro-id="65591361-751c-4719-9db8-89a2b00c5fe9"><ac:plain-text-body><![CDATA[BASE REPOSITORY

|Kustomize_template_repository
|__ base
|_______ deployment.yaml
|_______ service.yaml
|___overlays
|_______ overlay_with_hpa
|_________ hpa.yaml
|_________ kustomization.yaml
|_______ overlay_with_cronjob
|_________ cronjob.yaml
|_________ kustomization.yaml
|_______ overlay_with_ingress
|_________ ingress.yaml
|_________ kustomization.yaml


APPLICATION REPOSITORY

|app_manifest_repository
|____ overlays
|______ dev
|_________ deployment-patch.yaml
|_________ kustomization.yaml
|______ prod
|_________ deployment-patch.yaml
|_________ hpa-patch.yaml
|_________ kustomization.yaml]]></ac:plain-text-body></ac:structured-macro><ac:structured-macro ac:name="info" ac:schema-version="1" ac:macro-id="67f0c15d-71c2-4bcf-9d40-0caee8bd5eed"><ac:rich-text-body><p>Base repo : <a href="https://bitbucket.org/getirdev/kustomize-base-manifests/src/poc-kustomize-centralized-repo/base/" data-card-appearance="inline">https://bitbucket.org/getirdev/kustomize-base-manifests/src/poc-kustomize-centralized-repo/base/</a> <br />Overlays for the base: <a href="https://bitbucket.org/getirdev/kustomize-base-manifests/src/poc-kustomize-centralized-repo/overlays/" data-card-appearance="inline">https://bitbucket.org/getirdev/kustomize-base-manifests/src/poc-kustomize-centralized-repo/overlays/</a>  (base and base overlays would constitute the base repo)</p><p>Application repo : <a href="https://bitbucket.org/getirdev/kustomize-base-manifests/src/poc-kustomize-centralized-repo/test-microservice/overlays/dev/" data-card-appearance="inline">https://bitbucket.org/getirdev/kustomize-base-manifests/src/poc-kustomize-centralized-repo/test-microservice/overlays/dev/</a>  (the generated manifest in the results)</p></ac:rich-text-body></ac:structured-macro><p>The Application Repository then extends and customizes the base template using overlays specific to different environments (e.g., dev and prod).</p><p>The base can be referenced using git from the application manifest repo. </p><table data-layout="default" ac:local-id="e4f49eee-742f-4f15-b3a8-2dd0dbf7a1d8"><tbody><tr><th><p><strong>Pros</strong></p></th><th><p><strong>Cons</strong></p></th></tr><tr><td><p>Flexibility to customize the manifest</p></td><td><p>Very complex structure with many moving parts</p></td></tr><tr><td><p>Native kubectl support</p></td><td><p>The aim of updating version at a single place would not be achieved as the overlay in the app_manifest_repo should also be updated (Best of my knowledge as and when I m writing this)</p></td></tr><tr><td><p>We are currently using kustomize ???? </p></td><td><p>Writing transformations for changing the metadata like name and labels on manifests is difficult. </p><p>Eg: If there is a reference of a service name in the deployment, a transfomer should be there in place to adapt the whole deployment to change the service name in accordance with the service name provided in the kustomization. </p></td></tr></tbody></table><blockquote><p>&ldquo;On a personal note, I wouldnt go with this approach seeing the complexity of achieving this and the fact that it doesn&rsquo;t solve the problem we are trying to solve&rdquo; &ndash; Vini</p></blockquote><h3>Kustomize with Helm</h3><p>Kustomize has helm plugin which enables the use of private helm charts and adds overlay patches to the manifests. This leverages the use of values.yaml but keeping the native kubectl kustomize in place. </p><p>Proposed structure</p><ac:structured-macro ac:name="code" ac:schema-version="1" ac:macro-id="ee189580-d91b-49dd-b3e3-a687b58312c7"><ac:plain-text-body><![CDATA[BASE REPOSITORY

|__Helm_template_repository
|____ Chart.yaml
|____ values.default.yaml
|____ templates
|_______ deployment.yaml
|_______ hpa.yaml
|_______ service.yaml

APPLICATION REPOSITORY

|app_manifest_repository
|____ overlays
|______ dev
|_________ deployment-patch.yaml
|_________ kustomization.yaml
|______ prod
|_________ deployment-patch.yaml
|_________ hpa-patch.yaml
|_________ kustomization.yaml]]></ac:plain-text-body></ac:structured-macro><ac:structured-macro ac:name="info" ac:schema-version="1" ac:macro-id="ec6a0ae2-2282-432d-b399-9c5fc7956eb5"><ac:rich-text-body><p>App repo: <a href="https://bitbucket.org/getirdev/kustomize-base-manifests/src/poc-helm-centralized-repo/test-microservice/overlays/prod/" data-card-appearance="inline">https://bitbucket.org/getirdev/kustomize-base-manifests/src/poc-helm-centralized-repo/test-microservice/overlays/prod/</a> (Patch not being applied)</p></ac:rich-text-body></ac:structured-macro><p>There are issues with using the helmchartInflationGenerator from kustomize. I m analyzing this option further to see how I could make it work in the best possible fashion</p><p>Current problems</p><ul><li><p>kustomize supports helm charts to be deployed. but the patch is not being applied</p></li><li><p>The CD pipeline can be a bit complicated to use both together (Requirs templating from the helm and then using them to apply the patch)</p></li><li><p>use of multiple value files is not supported</p></li><li><p>Unsure about the support of sops (helm secrets plugin can be passed to the kustomize command <code>kustomize build --helm-command /opt/homebrew/bin/helm secrets --enable-helm</code> </p></li></ul><p>Another approach here would be to use the helm template first and then apply kustomize on the generated template. (Only reading examples knowledge) with the similar proposed structure</p><ac:structured-macro ac:name="code" ac:schema-version="1" ac:macro-id="6c94265a-0c5c-467c-a76f-13a0df5a2974"><ac:plain-text-body><![CDATA[helm template base_chart >> basechart.yaml
k kustomize build overlays/dev (this should refernce to the basechart.yaml generated)]]></ac:plain-text-body></ac:structured-macro><h3>Monorepo</h3><p>The base manifests and the application manifests can reside in a single repository, which would mean that the access to the base would be using relative paths. This can also help in using helm and kustomize according to the application&rsquo;s needs. (I haven't tested this, but theoretically, I cannot see any reasons that it wouldn't work)</p><p>Proposed structure</p><ac:structured-macro ac:name="code" ac:schema-version="1" ac:macro-id="b11af580-559c-477f-b298-605075558b72"><ac:plain-text-body><![CDATA[BASE REPOSITORY

|__Helm_template_repository
|____ Chart.yaml
|____ values.default.yaml
|____ templates
|_______ deployment.yaml
|_______ hpa.yaml
|_______ service.yaml
|
|
|Kustomize_template_repository
|__ base
|_______ deployment.yaml
|_______ service.yaml
|___overlays
|_______ overlay_with_hpa
|_________ hpa.yaml
|_________ kustomization.yaml
|_______ overlay_with_cronjob
|_________ cronjob.yaml
|_________ kustomization.yaml
|_______ overlay_with_ingress
|_________ ingress.yaml
|_________ kustomization.yaml
|
|
|app1_kustomize_repository
|____ overlays
|______ dev
|_________ deployment-patch.yaml
|_________ kustomization.yaml
|______ prod
|_________ deployment-patch.yaml
|_________ hpa-patch.yaml
|_________ kustomization.yaml
|
|
|__app2_helm_repository
|____ Chart.yaml 
|____ values.default.override.yaml
|____ dev
|_______ values.dev.yaml
|_______ secrets.dev.yaml
|____ prod
|_______ values.prod.yaml
|_______ secrets.prod.yaml]]></ac:plain-text-body></ac:structured-macro><ac:structured-macro ac:name="info" ac:schema-version="1" ac:macro-id="15893dba-55d9-4053-a51d-dfa009bd9d5e"><ac:rich-text-body><p>The example already has the microservice residing in the same repo and has been tested with relative paths</p></ac:rich-text-body></ac:structured-macro><table data-layout="default" ac:local-id="4958e0f9-e5ae-4340-85ac-10b701645530"><tbody><tr><th><p><strong>Pros</strong></p></th><th><p><strong>Cons</strong></p></th></tr><tr><td><p>Only relative paths</p></td><td><p>All manifests should be migrated to a single repo</p></td></tr><tr><td><p>Everything in a single place ??</p></td><td><p>RBAC wouldnt be possible and no separation per tribe</p></td></tr><tr><td><p /></td><td><p>A single source of truth for all microservices increases the risk of someone accidentally making changes to apps that were not meant</p></td></tr><tr><td><p /></td><td><p>Repo would be huge and the CD will have to clone it for every deployment (Depends on the CI/CD setup though)</p></td></tr></tbody></table><h2>Timeline:</h2><p><em>1 month for the creation of centralized manifest repo (Helm based)</em></p><p>1-2 months for adapting the existing manifest repos (Easier would be to keep both in parallel and make the switch gradually)</p><p>1 month of testing and improving</p><h2>Dependencies:</h2><p><em>The current workflow heavily relies on Kustomize and the patches are more or less equivalent to the whole base in some cases. Depends on the CI/CD workflow as well. Including secret management</em></p><h2>Alternatives Considered/Prior Art:</h2><p><em>All the approaches that are considered are documented. </em></p><p>Another approach would be to remain in the same setup. </p><h2>Operations:</h2><p><em>This would require additional effort on developers as they will have to adapt their kustomization.yaml according to the new approach. If using helm, the CD pipeline will have to be adapted. </em></p><p>The following are the identified tasks that have to be done and possible automation:</p><p><strong>Helm approach</strong></p><ol start="1"><li><p>Creation of centralized manifest repo: to be performed by the <strong>EED team</strong> taking into consideration all the manifests that are being used in all deployments. Create the CI to push the helm chart to be pushed to ECR or any Helm registry of our choice. </p></li><li><p>Updating the application manifest repo with the skeleton proposed in the RFC. This can be <strong>automated using kitchen templates</strong> or any other automation. </p></li><li><p>Updating values.yaml for each environment. This should be done by the <strong>developers</strong>, as they have ownership of the application values. </p></li><li><p>Update on the CI/CD to use helm upgrade instead of kustomize. </p></li></ol><p><strong>Kustomize approach</strong></p><ol start="1"><li><p>Creation of centralized manifest repo: to be performed by the <strong>EED team</strong> taking into consideration all the manifests that are being used in all deployments and writing overlays accordingly.</p></li><li><p>Updating the application manifest repo, to use the new base and different resources as overlays. This might <strong>not be automated</strong> as the resources and overlays can differ for each application. This would be on <strong>developers</strong>. </p></li></ol><h2>Security/Privacy/Compliance:</h2><p><em>What security/privacy/compliance aspects should be considered?</em></p><p><em>The security concern would be the storing of credentials to connect to a private helm repo (especially when using Spinnaker)</em></p><h2>Risks:</h2><p><em>What known risks exist? What factors may complicate your project?</em></p><table data-layout="default" ac:local-id="d7bce968-b1c9-4f73-b3a2-d370424c38be"><tbody><tr><th><p><strong>Helm approach</strong></p></th><th><p><strong>Kustomize</strong></p></th><th><p><strong>Helm + Kustomize</strong></p></th></tr><tr><td><p>New technology for org</p></td><td><p>Doesnt address the issue we are trying to tackle</p></td><td><p>Lack of team expertise</p></td></tr><tr><td><p>Security</p></td><td><p>Lack of team expertise</p></td><td><p>Service immaturity</p></td></tr><tr><td><p /></td><td><p>Compatibility</p></td><td><p>Compatibility</p></td></tr><tr><td><p /></td><td><p>Complex if we want to use transformers or anything fancy that kustomize offers to customize anything and everything (Very personal opinion)</p></td><td><p>High complexity</p></td></tr></tbody></table><p><em>Include security, complexity, compatibility, latency, service immaturity, lack of team expertise, etc.</em></p><h2>Revisions:</h2><ol start="1"><li><p><em>RFC Created</em></p></li><li><p><em>Update for major changes, including status changes.</em></p></li></ol><h2>Open Questions</h2><ol start="1"><li><p>What feature of kustomize are we using that cannot be fulfilled via Helm? </p></li><li><p>If we can&rsquo;t use Kustomize because developers still need to update the API version in the overlay, don&rsquo;t they also need to update the chart version with Helm?</p></li></ol><h2>Comments</h2><p>This a consolidation of the comments and a tl:dr; for everyone <ac:emoticon ac:name="smile" ac:emoji-shortname=":slight_smile:" ac:emoji-id="1f642" ac:emoji-fallback="ðŸ™‚" /> </p><ol start="1"><li><p>Why did I write the RFC on Confluence?</p><ol start="1"><li><p>I did not want the overhead of writing markdown</p></li><li><p>I do not like the commenting on the Pull request</p></li><li><p>If I want to contribute to someone&rsquo;s doc, I have to go through a git checkout, git push</p></li><li><p>Visually I find Confluence more appealing than reading a markdown file on a Bitbucket PR</p></li><li><p>Comments can be edited on Bitbucket as well.</p></li><li><p>There are other RFCs written on Confluence and they all look good <ac:emoticon ac:name="smile" ac:emoji-shortname=":slight_smile:" ac:emoji-id="1f642" ac:emoji-fallback="ðŸ™‚" /> </p></li><li><p>I have the Slack plugin to inform me of any comments that are posted in this doc and I can reply directly <ac:emoticon ac:name="blue-star" ac:emoji-shortname=":smiley:" ac:emoji-id="1f603" ac:emoji-fallback="ðŸ˜ƒ" /> </p></li></ol></li><li><p>With Helm can someone override templates?</p><ol start="1"><li><p>The helm chart is an aggregation of all the templates that we want. When a microservice is using a helm chart as a dependency, it can have its own template folder along with the chart dependency. One can have the default deployment template that comes from the base chart and have your own deployment on the template folder in the app manifest repo. Since we write our own base charts, we can always make any manifest not to be deployed. (Magic of helm templating and using values)</p></li><li><p>You can have multiple chart dependencies, multiple value files, override values that are specified in the default values file, and even have no value files</p></li></ol></li><li><p>How does the chart version work?</p><ol start="1"><li><p>We push the base chart to a registry (In the example here, I have pushed my base helm chart to <a href="https://eu-west-1.console.aws.amazon.com/ecr/repositories/private/289722705324/getir-app?region=eu-west-1">ECR</a>)</p></li><li><p>In the app manifest, we have to specify the Chart version to be used. This can be automated using the CI. (I personally do not like this automation as there can be breaking changes in the manifests and devs should acknowledge the changes)</p></li></ol></li><li><p>How can we change the HPA version?</p><ol start="1"><li><p>In case of using helm templates, the base is the place where this should be updated. If there are devs having their own templates in the manifest repo, they should handle it themselves. When the base is updated, this also requires the devs to update their manifest repo to the newly released version of the Chart and make changes according to the Changelog (Only relevant for any breaking changes)</p></li><li><p>In case of kustomize, the base has to be updated but also the overlays as it would be referencing the API version again. </p></li></ol></li><li><p>Avoid using both together - had many likes</p><ol start="1"><li><p>I have seen this approach being used on multiple projects. It is complicated. But helps us leverage the benefit of both. </p></li><li><p>I personally do not have enough kustomize expertise to make this work in the best possible fashion</p></li></ol></li><li><p>What would the update look like?</p><ol start="1"><li><p>If using helm, we will use Kitchen to create the Chart repo in all manifest repos with basic values.yaml files. The devs will have to adapt the values.yaml according to their needs. </p></li><li><p>If using kustomize, the only change would be the change of bases that they wanna use. I wouldn't personally recommend a Kitchen template for this, but we could of course update it with any automation</p></li></ol></li><li><p>What security issue do we have with Helm?</p><ol start="1"><li><p>The helm chart registry has to be authenticated in order to pull the charts. Git as a source is not supported atm. The ECR registry credentials have to be rotated using a cronjob similar to ecr-cred-helper in ArgoCD for instance.</p></li></ol></li><li><p>Why would Kustomize centralized repo not solve the issue?</p><ol start="1"><li><p>Kustomize overlays would have the API versions mentioned again. So there would be the need of adapting the overlays as well in case of a version change (Please correct me if I understood the overlays wrong)</p></li></ol></li><li><p>What compatibility issue do we have with kustomize?</p><ol start="1"><li><p>Using vars is not very easy for me in kustomize</p></li><li><p>As the dev, you would need to know the metadata in the base to write the overlay. </p></li></ol></li><li><p>Feel free to add your questions here or in the section above</p></li></ol><table data-layout="default" ac:local-id="97918d97-8571-451a-b101-78b010e79395"><colgroup><col style="width: 340.0px;" /><col style="width: 340.0px;" /></colgroup><tbody><tr><th data-highlight-colour="#f0f0f0"><p><strong>Reviewers:</strong></p></th><td><p /></td></tr><tr><th data-highlight-colour="#f0f0f0"><p><strong>Authors:</strong></p></th><td><p><ac:link><ri:user ri:account-id="64106a102cee496759e9f6b6" /></ac:link> </p></td></tr><tr><th data-highlight-colour="#f0f0f0"><p><strong>Status:</strong></p></th><td><p><strong><span style="color: rgb(255,255,255);">D</span></strong> <ac:structured-macro ac:name="status" ac:schema-version="1" ac:macro-id="2ff642fe-a764-45b8-ab65-6c9448a3975a"><ac:parameter ac:name="title">Discussion</ac:parameter><ac:parameter ac:name="colour">Yellow</ac:parameter></ac:structured-macro> <ac:structured-macro ac:name="status" ac:schema-version="1" ac:macro-id="55927e68-12be-401e-a961-362d9eeda671"><ac:parameter ac:name="title">active</ac:parameter><ac:parameter ac:name="colour">Green</ac:parameter></ac:structured-macro>  </p></td></tr><tr><th data-highlight-colour="#f0f0f0"><p><strong>Revisions:</strong></p></th><td><p /></td></tr><tr><th data-highlight-colour="#f0f0f0"><p><strong>Due Date:</strong></p></th><td><p><time datetime="2023-07-17" /> </p></td></tr></tbody></table><ac:structured-macro ac:name="toc" ac:schema-version="1" data-layout="default" ac:local-id="f039ca60-21d2-44f6-93af-6266f7dc9d07" ac:macro-id="23b992ec-ad35-4d25-afb4-b3838693d029"><ac:parameter ac:name="minLevel">1</ac:parameter><ac:parameter ac:name="maxLevel">6</ac:parameter><ac:parameter ac:name="outline">false</ac:parameter><ac:parameter ac:name="type">list</ac:parameter><ac:parameter ac:name="separator">brackets</ac:parameter><ac:parameter ac:name="printable">false</ac:parameter></ac:structured-macro><h2>Overview:</h2><p><em>Centraized manifest repository provides a location to store, version control and manage the deployment manifests or configuration files for Kubernetes. This repository can act as the single source of truth for the K8 manifests when it comes to helm deployments. In the case of kustomize, this would be the base with overlays of different combinations and applications pulling this base.</em></p><h2>Goals and Non-Goals:</h2><p>Goals: </p><ul><li><p><em>How can a centralized manifest repo fit in the current Getir setup with minimal changes. </em></p></li><li><p><em>How to leverage Helm and/or Kustomize to the best </em></p></li></ul><p>Non-Goal:</p><ul><li><p><em>How the setup would fit in the CD solution.</em></p></li></ul><h2>Background &amp; Motivation:</h2><p><em>Currently, the manifest repos are located in each application separately which makes it very difficult to change the base templates version or introduce mandatory configurations, annotations, and labels for the K8 deployments. </em></p><p>Developers can also find it difficult to use the best practices in kustomize or Helm.</p><p><em>Terms: GitOps, Helm, Kustomize</em></p><ac:structured-macro ac:name="info" ac:schema-version="1" ac:macro-id="35c644b4-ad9c-472c-ab1c-3e6e99257b16"><ac:rich-text-body><p>Relevant links (If you are skim reader like me, feel free to navigate through the links to get the overall picture <ac:emoticon ac:name="smile" ac:emoji-shortname=":slight_smile:" ac:emoji-id="1f642" ac:emoji-fallback="ðŸ™‚" /> )</p><p><a href="https://bitbucket.org/getirdev/kustomize-base-manifests/src/poc-helm-centralized-repo/" data-card-appearance="inline">https://bitbucket.org/getirdev/kustomize-base-manifests/src/poc-helm-centralized-repo/</a> - helm</p><p><a href="https://bitbucket.org/getirdev/kustomize-base-manifests/src/poc-kustomize-centralized-repo/" data-card-appearance="inline">https://bitbucket.org/getirdev/kustomize-base-manifests/src/poc-kustomize-centralized-repo/</a> - kustomize </p><p><a href="https://bitbucket.org/getirdev/piebot-manifests/src/poc-kustomize-centralized-repo/" data-card-appearance="inline">https://bitbucket.org/getirdev/piebot-manifests/src/poc-kustomize-centralized-repo/</a> - example</p><p><a href="https://argocd-dev.tower.getirapi.com/applications/argocd-dev/piebot-helm-way?view=tree&amp;resource=">Helm deployment on argocd</a></p><p><a href="https://argocd-dev.tower.getirapi.com/applications/argocd-dev/piebot-kustomize-way?view=tree&amp;resource=">Kustomize deployment on argocd</a></p><p><a href="https://eu-west-1.console.aws.amazon.com/ecr/repositories/private/289722705324/getir-app?region=eu-west-1">Helm chart registry</a></p></ac:rich-text-body></ac:structured-macro><h2>Design:</h2><p>The base manifest repo should be separate from the application repo and the platform team should own the manifest to leverage the best knowledge of the tools. </p><p>The solution would also involve if we want to use helm or kustomize. </p><h3>Using Helm</h3><ac:structured-macro ac:name="info" ac:schema-version="1" ac:macro-id="773e7dd2-0c9a-4fea-8056-25086fef8d88"><ac:rich-text-body><p>Helm is a package manager for Kubernetes that allows you to define, install, and manage applications as Helm charts. A Helm chart is a collection of Kubernetes manifests (YAML files) that describe the resources required to deploy a particular application.</p></ac:rich-text-body></ac:structured-macro><p>Proposed structure: </p><ac:structured-macro ac:name="code" ac:schema-version="1" ac:macro-id="33a9f89e-c33b-41ee-932d-6e8622bc45a5"><ac:plain-text-body><![CDATA[BASE REPOSITORY

|__Helm_template_repository
|____ Chart.yaml
|____ values.default.yaml
|____ templates
|_______ deployment.yaml
|_______ hpa.yaml
|_______ service.yaml

APPLICATION REPOSITORY

|__app_manifest_repository
|____ Chart.yaml 
|____ values.default.override.yaml
|____ dev
|_______ values.dev.yaml
|_______ secrets.dev.yaml
|____ prod
|_______ values.prod.yaml
|_______ secrets.prod.yaml

]]></ac:plain-text-body></ac:structured-macro><ac:structured-macro ac:name="info" ac:schema-version="1" ac:macro-id="a845d55b-46c7-4769-a758-e0417b3fa757"><ac:rich-text-body><p>Manifest repo: <a href="https://bitbucket.org/getirdev/kustomize-base-manifests/src/poc-helm-centralized-repo/manifest/" data-card-appearance="inline">https://bitbucket.org/getirdev/kustomize-base-manifests/src/poc-helm-centralized-repo/manifest/</a> </p><p>Application repo: <a href="https://bitbucket.org/getirdev/kustomize-base-manifests/src/poc-helm-centralized-repo/test-microservice/chart/" data-card-appearance="inline">https://bitbucket.org/getirdev/kustomize-base-manifests/src/poc-helm-centralized-repo/test-microservice/chart/</a> </p><p>The results of the templating can be found on the results folder</p></ac:rich-text-body></ac:structured-macro><p>By separating the Base Repository from the Application Repository, we can maintain a centralized source of truth for the base Helm chart while allowing applications to customize and extend the chart based on their specific needs. This structure promotes reusability, consistency, and efficient management of deployments across multiple applications or environments.</p><p>The helm chart can be pushed to a private chart-museum or ECR (AWS supports using ECR as helm registry)</p><p>We could use kustomize on top of helm charts and manipulate the manifest with overlay patches (Example below)</p><table data-layout="default" ac:local-id="7303124a-37d4-47aa-80a6-b3f31d6fd44d"><tbody><tr><th><p><strong>Pros</strong></p></th><th><p><strong>Cons</strong></p></th></tr><tr><td><p>Easy for developers to manipulate values.yaml files, no knowledge of Kubernetes manifest required</p></td><td><p>Using a private helm registry is not very easy when it comes to using them as dependency chart. </p></td></tr><tr><td><p>Versioning is very easy and would be backward compatible as all helm charts versions would be saved</p></td><td><p>Creating the template which would fit all the options used in the applications can be some effort</p></td></tr><tr><td><p>Helm rollbacks are very easy without any 3rd party tools. </p></td><td><p /></td></tr><tr><td><p /></td><td><p /></td></tr></tbody></table><h3>Using Kustomize</h3><ac:structured-macro ac:name="info" ac:schema-version="1" ac:macro-id="ca4a635d-6b98-4c81-9f6a-a16e807a85f3"><ac:rich-text-body><p>Kustomize is a native configuration management tool for Kubernetes that allows you to customize and manage Kubernetes manifests using overlays and patches. With Kustomize, you can define base manifests and then apply overlays to modify or extend them based on different environments or requirements.</p></ac:rich-text-body></ac:structured-macro><p>Proposed Structure: </p><ac:structured-macro ac:name="code" ac:schema-version="1" ac:macro-id="65591361-751c-4719-9db8-89a2b00c5fe9"><ac:plain-text-body><![CDATA[BASE REPOSITORY

|Kustomize_template_repository
|__ base
|_______ deployment.yaml
|_______ service.yaml
|___overlays
|_______ overlay_with_hpa
|_________ hpa.yaml
|_________ kustomization.yaml
|_______ overlay_with_cronjob
|_________ cronjob.yaml
|_________ kustomization.yaml
|_______ overlay_with_ingress
|_________ ingress.yaml
|_________ kustomization.yaml


APPLICATION REPOSITORY

|app_manifest_repository
|____ overlays
|______ dev
|_________ deployment-patch.yaml
|_________ kustomization.yaml
|______ prod
|_________ deployment-patch.yaml
|_________ hpa-patch.yaml
|_________ kustomization.yaml]]></ac:plain-text-body></ac:structured-macro><ac:structured-macro ac:name="info" ac:schema-version="1" ac:macro-id="67f0c15d-71c2-4bcf-9d40-0caee8bd5eed"><ac:rich-text-body><p>Base repo : <a href="https://bitbucket.org/getirdev/kustomize-base-manifests/src/poc-kustomize-centralized-repo/base/" data-card-appearance="inline">https://bitbucket.org/getirdev/kustomize-base-manifests/src/poc-kustomize-centralized-repo/base/</a> <br />Overlays for the base: <a href="https://bitbucket.org/getirdev/kustomize-base-manifests/src/poc-kustomize-centralized-repo/overlays/" data-card-appearance="inline">https://bitbucket.org/getirdev/kustomize-base-manifests/src/poc-kustomize-centralized-repo/overlays/</a>  (base and base overlays would constitute the base repo)</p><p>Application repo : <a href="https://bitbucket.org/getirdev/kustomize-base-manifests/src/poc-kustomize-centralized-repo/test-microservice/overlays/dev/" data-card-appearance="inline">https://bitbucket.org/getirdev/kustomize-base-manifests/src/poc-kustomize-centralized-repo/test-microservice/overlays/dev/</a>  (the generated manifest in the results)</p></ac:rich-text-body></ac:structured-macro><p>The Application Repository then extends and customizes the base template using overlays specific to different environments (e.g., dev and prod).</p><p>The base can be referenced using git from the application manifest repo. </p><table data-layout="default" ac:local-id="e4f49eee-742f-4f15-b3a8-2dd0dbf7a1d8"><tbody><tr><th><p><strong>Pros</strong></p></th><th><p><strong>Cons</strong></p></th></tr><tr><td><p>Flexibility to customize the manifest</p></td><td><p>Very complex structure with many moving parts</p></td></tr><tr><td><p>Native kubectl support</p></td><td><p>The aim of updating version at a single place would not be achieved as the overlay in the app_manifest_repo should also be updated (Best of my knowledge as and when I m writing this)</p></td></tr><tr><td><p>We are currently using kustomize ???? </p></td><td><p>Writing transformations for changing the metadata like name and labels on manifests is difficult. </p><p>Eg: If there is a reference of a service name in the deployment, a transfomer should be there in place to adapt the whole deployment to change the service name in accordance with the service name provided in the kustomization. </p></td></tr></tbody></table><blockquote><p>&ldquo;On a personal note, I wouldnt go with this approach seeing the complexity of achieving this and the fact that it doesn&rsquo;t solve the problem we are trying to solve&rdquo; &ndash; Vini</p></blockquote><h3>Kustomize with Helm</h3><p>Kustomize has helm plugin which enables the use of private helm charts and adds overlay patches to the manifests. This leverages the use of values.yaml but keeping the native kubectl kustomize in place. </p><p>Proposed structure</p><ac:structured-macro ac:name="code" ac:schema-version="1" ac:macro-id="ee189580-d91b-49dd-b3e3-a687b58312c7"><ac:plain-text-body><![CDATA[BASE REPOSITORY

|__Helm_template_repository
|____ Chart.yaml
|____ values.default.yaml
|____ templates
|_______ deployment.yaml
|_______ hpa.yaml
|_______ service.yaml

APPLICATION REPOSITORY

|app_manifest_repository
|____ overlays
|______ dev
|_________ deployment-patch.yaml
|_________ kustomization.yaml
|______ prod
|_________ deployment-patch.yaml
|_________ hpa-patch.yaml
|_________ kustomization.yaml]]></ac:plain-text-body></ac:structured-macro><ac:structured-macro ac:name="info" ac:schema-version="1" ac:macro-id="ec6a0ae2-2282-432d-b399-9c5fc7956eb5"><ac:rich-text-body><p>App repo: <a href="https://bitbucket.org/getirdev/kustomize-base-manifests/src/poc-helm-centralized-repo/test-microservice/overlays/prod/" data-card-appearance="inline">https://bitbucket.org/getirdev/kustomize-base-manifests/src/poc-helm-centralized-repo/test-microservice/overlays/prod/</a> (Patch not being applied)</p></ac:rich-text-body></ac:structured-macro><p>There are issues with using the helmchartInflationGenerator from kustomize. I m analyzing this option further to see how I could make it work in the best possible fashion</p><p>Current problems</p><ul><li><p>kustomize supports helm charts to be deployed. but the patch is not being applied</p></li><li><p>The CD pipeline can be a bit complicated to use both together (Requirs templating from the helm and then using them to apply the patch)</p></li><li><p>use of multiple value files is not supported</p></li><li><p>Unsure about the support of sops (helm secrets plugin can be passed to the kustomize command <code>kustomize build --helm-command /opt/homebrew/bin/helm secrets --enable-helm</code> </p></li></ul><p>Another approach here would be to use the helm template first and then apply kustomize on the generated template. (Only reading examples knowledge) with the similar proposed structure</p><ac:structured-macro ac:name="code" ac:schema-version="1" ac:macro-id="6c94265a-0c5c-467c-a76f-13a0df5a2974"><ac:plain-text-body><![CDATA[helm template base_chart >> basechart.yaml
k kustomize build overlays/dev (this should refernce to the basechart.yaml generated)]]></ac:plain-text-body></ac:structured-macro><h3>Monorepo</h3><p>The base manifests and the application manifests can reside in a single repository, which would mean that the access to the base would be using relative paths. This can also help in using helm and kustomize according to the application&rsquo;s needs. (I haven't tested this, but theoretically, I cannot see any reasons that it wouldn't work)</p><p>Proposed structure</p><ac:structured-macro ac:name="code" ac:schema-version="1" ac:macro-id="b11af580-559c-477f-b298-605075558b72"><ac:plain-text-body><![CDATA[BASE REPOSITORY

|__Helm_template_repository
|____ Chart.yaml
|____ values.default.yaml
|____ templates
|_______ deployment.yaml
|_______ hpa.yaml
|_______ service.yaml
|
|
|Kustomize_template_repository
|__ base
|_______ deployment.yaml
|_______ service.yaml
|___overlays
|_______ overlay_with_hpa
|_________ hpa.yaml
|_________ kustomization.yaml
|_______ overlay_with_cronjob
|_________ cronjob.yaml
|_________ kustomization.yaml
|_______ overlay_with_ingress
|_________ ingress.yaml
|_________ kustomization.yaml
|
|
|app1_kustomize_repository
|____ overlays
|______ dev
|_________ deployment-patch.yaml
|_________ kustomization.yaml
|______ prod
|_________ deployment-patch.yaml
|_________ hpa-patch.yaml
|_________ kustomization.yaml
|
|
|__app2_helm_repository
|____ Chart.yaml 
|____ values.default.override.yaml
|____ dev
|_______ values.dev.yaml
|_______ secrets.dev.yaml
|____ prod
|_______ values.prod.yaml
|_______ secrets.prod.yaml]]></ac:plain-text-body></ac:structured-macro><ac:structured-macro ac:name="info" ac:schema-version="1" ac:macro-id="15893dba-55d9-4053-a51d-dfa009bd9d5e"><ac:rich-text-body><p>The example already has the microservice residing in the same repo and has been tested with relative paths</p></ac:rich-text-body></ac:structured-macro><table data-layout="default" ac:local-id="4958e0f9-e5ae-4340-85ac-10b701645530"><tbody><tr><th><p><strong>Pros</strong></p></th><th><p><strong>Cons</strong></p></th></tr><tr><td><p>Only relative paths</p></td><td><p>All manifests should be migrated to a single repo</p></td></tr><tr><td><p>Everything in a single place ??</p></td><td><p>RBAC wouldnt be possible and no separation per tribe</p></td></tr><tr><td><p /></td><td><p>A single source of truth for all microservices increases the risk of someone accidentally making changes to apps that were not meant</p></td></tr><tr><td><p /></td><td><p>Repo would be huge and the CD will have to clone it for every deployment (Depends on the CI/CD setup though)</p></td></tr></tbody></table><h2>Timeline:</h2><p><em>1 month for the creation of centralized manifest repo (Helm based)</em></p><p>1-2 months for adapting the existing manifest repos (Easier would be to keep both in parallel and make the switch gradually)</p><p>1 month of testing and improving</p><h2>Dependencies:</h2><p><em>The current workflow heavily relies on Kustomize and the patches are more or less equivalent to the whole base in some cases. Depends on the CI/CD workflow as well. Including secret management</em></p><h2>Alternatives Considered/Prior Art:</h2><p><em>All the approaches that are considered are documented. </em></p><p>Another approach would be to remain in the same setup. </p><h2>Operations:</h2><p><em>This would require additional effort on developers as they will have to adapt their kustomization.yaml according to the new approach. If using helm, the CD pipeline will have to be adapted. </em></p><p>The following are the identified tasks that have to be done and possible automation:</p><p><strong>Helm approach</strong></p><ol start="1"><li><p>Creation of centralized manifest repo: to be performed by the <strong>EED team</strong> taking into consideration all the manifests that are being used in all deployments. Create the CI to push the helm chart to be pushed to ECR or any Helm registry of our choice. </p></li><li><p>Updating the application manifest repo with the skeleton proposed in the RFC. This can be <strong>automated using kitchen templates</strong> or any other automation. </p></li><li><p>Updating values.yaml for each environment. This should be done by the <strong>developers</strong>, as they have ownership of the application values. </p></li><li><p>Update on the CI/CD to use helm upgrade instead of kustomize. </p></li></ol><p><strong>Kustomize approach</strong></p><ol start="1"><li><p>Creation of centralized manifest repo: to be performed by the <strong>EED team</strong> taking into consideration all the manifests that are being used in all deployments and writing overlays accordingly.</p></li><li><p>Updating the application manifest repo, to use the new base and different resources as overlays. This might <strong>not be automated</strong> as the resources and overlays can differ for each application. This would be on <strong>developers</strong>. </p></li></ol><h2>Security/Privacy/Compliance:</h2><p><em>What security/privacy/compliance aspects should be considered?</em></p><p><em>The security concern would be the storing of credentials to connect to a private helm repo (especially when using Spinnaker)</em></p><h2>Risks:</h2><p><em>What known risks exist? What factors may complicate your project?</em></p><table data-layout="default" ac:local-id="d7bce968-b1c9-4f73-b3a2-d370424c38be"><tbody><tr><th><p><strong>Helm approach</strong></p></th><th><p><strong>Kustomize</strong></p></th><th><p><strong>Helm + Kustomize</strong></p></th></tr><tr><td><p>New technology for org</p></td><td><p>Doesnt address the issue we are trying to tackle</p></td><td><p>Lack of team expertise</p></td></tr><tr><td><p>Security</p></td><td><p>Lack of team expertise</p></td><td><p>Service immaturity</p></td></tr><tr><td><p /></td><td><p>Compatibility</p></td><td><p>Compatibility</p></td></tr><tr><td><p /></td><td><p>Complex if we want to use transformers or anything fancy that kustomize offers to customize anything and everything (Very personal opinion)</p></td><td><p>High complexity</p></td></tr></tbody></table><p><em>Include security, complexity, compatibility, latency, service immaturity, lack of team expertise, etc.</em></p><h2>Revisions:</h2><ol start="1"><li><p><em>RFC Created</em></p></li><li><p><em>Update for major changes, including status changes.</em></p></li></ol><h2>Open Questions</h2><ol start="1"><li><p>What feature of kustomize are we using that cannot be fulfilled via Helm? </p></li><li><p>If we can&rsquo;t use Kustomize because developers still need to update the API version in the overlay, don&rsquo;t they also need to update the chart version with Helm?</p></li></ol><h2>Comments</h2><p>This a consolidation of the comments and a tl:dr; for everyone <ac:emoticon ac:name="smile" ac:emoji-shortname=":slight_smile:" ac:emoji-id="1f642" ac:emoji-fallback="ðŸ™‚" /> </p><ol start="1"><li><p>Why did I write the RFC on Confluence?</p><ol start="1"><li><p>I did not want the overhead of writing markdown</p></li><li><p>I do not like the commenting on the Pull request</p></li><li><p>If I want to contribute to someone&rsquo;s doc, I have to go through a git checkout, git push</p></li><li><p>Visually I find Confluence more appealing than reading a markdown file on a Bitbucket PR</p></li><li><p>Comments can be edited on Bitbucket as well.</p></li><li><p>There are other RFCs written on Confluence and they all look good <ac:emoticon ac:name="smile" ac:emoji-shortname=":slight_smile:" ac:emoji-id="1f642" ac:emoji-fallback="ðŸ™‚" /> </p></li><li><p>I have the Slack plugin to inform me of any comments that are posted in this doc and I can reply directly <ac:emoticon ac:name="blue-star" ac:emoji-shortname=":smiley:" ac:emoji-id="1f603" ac:emoji-fallback="ðŸ˜ƒ" /> </p></li></ol></li><li><p>With Helm can someone override templates?</p><ol start="1"><li><p>The helm chart is an aggregation of all the templates that we want. When a microservice is using a helm chart as a dependency, it can have its own template folder along with the chart dependency. One can have the default deployment template that comes from the base chart and have your own deployment on the template folder in the app manifest repo. Since we write our own base charts, we can always make any manifest not to be deployed. (Magic of helm templating and using values)</p></li><li><p>You can have multiple chart dependencies, multiple value files, override values that are specified in the default values file, and even have no value files</p></li></ol></li><li><p>How does the chart version work?</p><ol start="1"><li><p>We push the base chart to a registry (In the example here, I have pushed my base helm chart to <a href="https://eu-west-1.console.aws.amazon.com/ecr/repositories/private/289722705324/getir-app?region=eu-west-1">ECR</a>)</p></li><li><p>In the app manifest, we have to specify the Chart version to be used. This can be automated using the CI. (I personally do not like this automation as there can be breaking changes in the manifests and devs should acknowledge the changes)</p></li></ol></li><li><p>How can we change the HPA version?</p><ol start="1"><li><p>In case of using helm templates, the base is the place where this should be updated. If there are devs having their own templates in the manifest repo, they should handle it themselves. When the base is updated, this also requires the devs to update their manifest repo to the newly released version of the Chart and make changes according to the Changelog (Only relevant for any breaking changes)</p></li><li><p>In case of kustomize, the base has to be updated but also the overlays as it would be referencing the API version again. </p></li></ol></li><li><p>Avoid using both together - had many likes</p><ol start="1"><li><p>I have seen this approach being used on multiple projects. It is complicated. But helps us leverage the benefit of both. </p></li><li><p>I personally do not have enough kustomize expertise to make this work in the best possible fashion</p></li></ol></li><li><p>What would the update look like?</p><ol start="1"><li><p>If using helm, we will use Kitchen to create the Chart repo in all manifest repos with basic values.yaml files. The devs will have to adapt the values.yaml according to their needs. </p></li><li><p>If using kustomize, the only change would be the change of bases that they wanna use. I wouldn't personally recommend a Kitchen template for this, but we could of course update it with any automation</p></li></ol></li><li><p>What security issue do we have with Helm?</p><ol start="1"><li><p>The helm chart registry has to be authenticated in order to pull the charts. Git as a source is not supported atm. The ECR registry credentials have to be rotated using a cronjob similar to ecr-cred-helper in ArgoCD for instance.</p></li></ol></li><li><p>Why would Kustomize centralized repo not solve the issue?</p><ol start="1"><li><p>Kustomize overlays would have the API versions mentioned again. So there would be the need of adapting the overlays as well in case of a version change (Please correct me if I understood the overlays wrong)</p></li></ol></li><li><p>What compatibility issue do we have with kustomize?</p><ol start="1"><li><p>Using vars is not very easy for me in kustomize</p></li><li><p>As the dev, you would need to know the metadata in the base to write the overlay. </p></li></ol></li><li><p>Feel free to add your questions here or in the section above</p></li></ol><table data-layout="default" ac:local-id="97918d97-8571-451a-b101-78b010e79395"><colgroup><col style="width: 340.0px;" /><col style="width: 340.0px;" /></colgroup><tbody><tr><th data-highlight-colour="#f0f0f0"><p><strong>Reviewers:</strong></p></th><td><p>ggg</p></td></tr><tr><th data-highlight-colour="#f0f0f0"><p><strong>Authors:</strong></p></th><td><p>sbg</p></td></tr><tr><th data-highlight-colour="#f0f0f0"><p><strong>Status:</strong></p></th><td><p><strong><span style="color: rgb(255,255,255);">D</span></strong> <ac:structured-macro ac:name="status" ac:schema-version="1" ac:macro-id="2ff642fe-a764-45b8-ab65-6c9448a3975a"><ac:parameter ac:name="title">Discussion</ac:parameter><ac:parameter ac:name="colour">Yellow</ac:parameter></ac:structured-macro> <ac:structured-macro ac:name="status" ac:schema-version="1" ac:macro-id="55927e68-12be-401e-a961-362d9eeda671"><ac:parameter ac:name="title">active</ac:parameter><ac:parameter ac:name="colour">Green</ac:parameter></ac:structured-macro>  </p></td></tr><tr><th data-highlight-colour="#f0f0f0"><p><strong>Revisions:</strong></p></th><td><p /></td></tr><tr><th data-highlight-colour="#f0f0f0"><p><strong>Due Date:</strong></p></th><td><p><time datetime="2023-07-17" /> </p></td></tr></tbody></table><ac:structured-macro ac:name="toc" ac:schema-version="1" data-layout="default" ac:local-id="f039ca60-21d2-44f6-93af-6266f7dc9d07" ac:macro-id="23b992ec-ad35-4d25-afb4-b3838693d029"><ac:parameter ac:name="minLevel">1</ac:parameter><ac:parameter ac:name="maxLevel">6</ac:parameter><ac:parameter ac:name="outline">false</ac:parameter><ac:parameter ac:name="type">list</ac:parameter><ac:parameter ac:name="separator">brackets</ac:parameter><ac:parameter ac:name="printable">false</ac:parameter></ac:structured-macro><h2>Overview:</h2><p><em>Centraized manifest repository provides a location to store, version control and manage the deployment manifests or configuration files for Kubernetes. This repository can act as the single source of truth for the K8 manifests when it comes to helm deployments. In the case of kustomize, this would be the base with overlays of different combinations and applications pulling this base.</em></p><h2>Goals and Non-Goals:</h2><p>Goals: </p><ul><li><p><em>How can a centralized manifest repo fit in the current Getir setup with minimal changes. </em></p></li><li><p><em>How to leverage Helm and/or Kustomize to the best </em></p></li></ul><p>Non-Goal:</p><ul><li><p><em>How the setup would fit in the CD solution.</em></p></li></ul><h2>Background &amp; Motivation:</h2><p><em>Currently, the manifest repos are located in each application separately which makes it very difficult to change the base templates version or introduce mandatory configurations, annotations, and labels for the K8 deployments. </em></p><p>Developers can also find it difficult to use the best practices in kustomize or Helm.</p><p><em>Terms: GitOps, Helm, Kustomize</em></p><ac:structured-macro ac:name="info" ac:schema-version="1" ac:macro-id="472ac97c-c59b-48d6-8456-79f376f97ac2"><ac:rich-text-body><p>Relevant links (If you are skim reader like me, feel free to navigate through the links to get the overall picture <ac:emoticon ac:name="smile" ac:emoji-shortname=":slight_smile:" ac:emoji-id="1f642" ac:emoji-fallback="ðŸ™‚" /> )</p><p><a href="https://bitbucket.org/getirdev/kustomize-base-manifests/src/poc-helm-centralized-repo/" data-card-appearance="inline">https://bitbucket.org/getirdev/kustomize-base-manifests/src/poc-helm-centralized-repo/</a> - helm</p><p><a href="https://bitbucket.org/getirdev/kustomize-base-manifests/src/poc-kustomize-centralized-repo/" data-card-appearance="inline">https://bitbucket.org/getirdev/kustomize-base-manifests/src/poc-kustomize-centralized-repo/</a> - kustomize </p><p><a href="https://bitbucket.org/getirdev/piebot-manifests/src/poc-kustomize-centralized-repo/" data-card-appearance="inline">https://bitbucket.org/getirdev/piebot-manifests/src/poc-kustomize-centralized-repo/</a> - example</p><p><a href="https://argocd-dev.tower.getirapi.com/applications/argocd-dev/piebot-helm-way?view=tree&amp;resource=">Helm deployment on argocd</a></p><p><a href="https://argocd-dev.tower.getirapi.com/applications/argocd-dev/piebot-kustomize-way?view=tree&amp;resource=">Kustomize deployment on argocd</a></p><p><a href="https://eu-west-1.console.aws.amazon.com/ecr/repositories/private/289722705324/getir-app?region=eu-west-1">Helm chart registry</a></p></ac:rich-text-body></ac:structured-macro><h2>Design:</h2><p>The base manifest repo should be separate from the application repo and the platform team should own the manifest to leverage the best knowledge of the tools. </p><p>The solution would also involve if we want to use helm or kustomize. </p><h3>Using Helm</h3><ac:structured-macro ac:name="info" ac:schema-version="1" ac:macro-id="a63b6ea1-bc92-4937-9d2a-5d53f018719f"><ac:rich-text-body><p>Helm is a package manager for Kubernetes that allows you to define, install, and manage applications as Helm charts. A Helm chart is a collection of Kubernetes manifests (YAML files) that describe the resources required to deploy a particular application.</p></ac:rich-text-body></ac:structured-macro><p>Proposed structure: </p><ac:structured-macro ac:name="code" ac:schema-version="1" ac:macro-id="49f1c810-0de4-478f-a435-9c1d55c33b5f"><ac:plain-text-body><![CDATA[BASE REPOSITORY

|__Helm_template_repository
|____ Chart.yaml
|____ values.default.yaml
|____ templates
|_______ deployment.yaml
|_______ hpa.yaml
|_______ service.yaml

APPLICATION REPOSITORY

|__app_manifest_repository
|____ Chart.yaml 
|____ values.default.override.yaml
|____ dev
|_______ values.dev.yaml
|_______ secrets.dev.yaml
|____ prod
|_______ values.prod.yaml
|_______ secrets.prod.yaml

]]></ac:plain-text-body></ac:structured-macro><ac:structured-macro ac:name="info" ac:schema-version="1" ac:macro-id="b5cd2574-b747-41b1-8e21-e27b54485065"><ac:rich-text-body><p>Manifest repo: <a href="https://bitbucket.org/getirdev/kustomize-base-manifests/src/poc-helm-centralized-repo/manifest/" data-card-appearance="inline">https://bitbucket.org/getirdev/kustomize-base-manifests/src/poc-helm-centralized-repo/manifest/</a> </p><p>Application repo: <a href="https://bitbucket.org/getirdev/kustomize-base-manifests/src/poc-helm-centralized-repo/test-microservice/chart/" data-card-appearance="inline">https://bitbucket.org/getirdev/kustomize-base-manifests/src/poc-helm-centralized-repo/test-microservice/chart/</a> </p><p>The results of the templating can be found on the results folder</p></ac:rich-text-body></ac:structured-macro><p>By separating the Base Repository from the Application Repository, we can maintain a centralized source of truth for the base Helm chart while allowing applications to customize and extend the chart based on their specific needs. This structure promotes reusability, consistency, and efficient management of deployments across multiple applications or environments.</p><p>The helm chart can be pushed to a private chart-museum or ECR (AWS supports using ECR as helm registry)</p><p>We could use kustomize on top of helm charts and manipulate the manifest with overlay patches (Example below)</p><table data-layout="default" ac:local-id="7303124a-37d4-47aa-80a6-b3f31d6fd44d"><tbody><tr><th><p><strong>Pros</strong></p></th><th><p><strong>Cons</strong></p></th></tr><tr><td><p>Easy for developers to manipulate values.yaml files, no knowledge of Kubernetes manifest required</p></td><td><p>Using a private helm registry is not very easy when it comes to using them as dependency chart. </p></td></tr><tr><td><p>Versioning is very easy and would be backward compatible as all helm charts versions would be saved</p></td><td><p>Creating the template which would fit all the options used in the applications can be some effort</p></td></tr><tr><td><p>Helm rollbacks are very easy without any 3rd party tools. </p></td><td><p /></td></tr><tr><td><p /></td><td><p /></td></tr></tbody></table><h3>Using Kustomize</h3><ac:structured-macro ac:name="info" ac:schema-version="1" ac:macro-id="6c92734b-6e4c-4045-8fbd-da8342f11fde"><ac:rich-text-body><p>Kustomize is a native configuration management tool for Kubernetes that allows you to customize and manage Kubernetes manifests using overlays and patches. With Kustomize, you can define base manifests and then apply overlays to modify or extend them based on different environments or requirements.</p></ac:rich-text-body></ac:structured-macro><p>Proposed Structure: </p><ac:structured-macro ac:name="code" ac:schema-version="1" ac:macro-id="b96db4ed-af02-4194-95ff-8235735001ef"><ac:plain-text-body><![CDATA[BASE REPOSITORY

|Kustomize_template_repository
|__ base
|_______ deployment.yaml
|_______ service.yaml
|___overlays
|_______ overlay_with_hpa
|_________ hpa.yaml
|_________ kustomization.yaml
|_______ overlay_with_cronjob
|_________ cronjob.yaml
|_________ kustomization.yaml
|_______ overlay_with_ingress
|_________ ingress.yaml
|_________ kustomization.yaml


APPLICATION REPOSITORY

|app_manifest_repository
|____ overlays
|______ dev
|_________ deployment-patch.yaml
|_________ kustomization.yaml
|______ prod
|_________ deployment-patch.yaml
|_________ hpa-patch.yaml
|_________ kustomization.yaml]]></ac:plain-text-body></ac:structured-macro><ac:structured-macro ac:name="info" ac:schema-version="1" ac:macro-id="8e0ff291-8bed-42bc-8f3c-dd48a2502de9"><ac:rich-text-body><p>Base repo : <a href="https://bitbucket.org/getirdev/kustomize-base-manifests/src/poc-kustomize-centralized-repo/base/" data-card-appearance="inline">https://bitbucket.org/getirdev/kustomize-base-manifests/src/poc-kustomize-centralized-repo/base/</a> <br />Overlays for the base: <a href="https://bitbucket.org/getirdev/kustomize-base-manifests/src/poc-kustomize-centralized-repo/overlays/" data-card-appearance="inline">https://bitbucket.org/getirdev/kustomize-base-manifests/src/poc-kustomize-centralized-repo/overlays/</a>  (base and base overlays would constitute the base repo)</p><p>Application repo : <a href="https://bitbucket.org/getirdev/kustomize-base-manifests/src/poc-kustomize-centralized-repo/test-microservice/overlays/dev/" data-card-appearance="inline">https://bitbucket.org/getirdev/kustomize-base-manifests/src/poc-kustomize-centralized-repo/test-microservice/overlays/dev/</a>  (the generated manifest in the results)</p></ac:rich-text-body></ac:structured-macro><p>The Application Repository then extends and customizes the base template using overlays specific to different environments (e.g., dev and prod).</p><p>The base can be referenced using git from the application manifest repo. </p><table data-layout="default" ac:local-id="e4f49eee-742f-4f15-b3a8-2dd0dbf7a1d8"><tbody><tr><th><p><strong>Pros</strong></p></th><th><p><strong>Cons</strong></p></th></tr><tr><td><p>Flexibility to customize the manifest</p></td><td><p>Very complex structure with many moving parts</p></td></tr><tr><td><p>Native kubectl support</p></td><td><p>The aim of updating version at a single place would not be achieved as the overlay in the app_manifest_repo should also be updated (Best of my knowledge as and when I m writing this)</p></td></tr><tr><td><p>We are currently using kustomize ???? </p></td><td><p>Writing transformations for changing the metadata like name and labels on manifests is difficult. </p><p>Eg: If there is a reference of a service name in the deployment, a transfomer should be there in place to adapt the whole deployment to change the service name in accordance with the service name provided in the kustomization. </p></td></tr></tbody></table><blockquote><p>&ldquo;On a personal note, I wouldnt go with this approach seeing the complexity of achieving this and the fact that it doesn&rsquo;t solve the problem we are trying to solve&rdquo; &ndash; Vini</p></blockquote><h3>Kustomize with Helm</h3><p>Kustomize has helm plugin which enables the use of private helm charts and adds overlay patches to the manifests. This leverages the use of values.yaml but keeping the native kubectl kustomize in place. </p><p>Proposed structure</p><ac:structured-macro ac:name="code" ac:schema-version="1" ac:macro-id="42676fb2-5fb6-468f-b753-27c9be777877"><ac:plain-text-body><![CDATA[BASE REPOSITORY

|__Helm_template_repository
|____ Chart.yaml
|____ values.default.yaml
|____ templates
|_______ deployment.yaml
|_______ hpa.yaml
|_______ service.yaml

APPLICATION REPOSITORY

|app_manifest_repository
|____ overlays
|______ dev
|_________ deployment-patch.yaml
|_________ kustomization.yaml
|______ prod
|_________ deployment-patch.yaml
|_________ hpa-patch.yaml
|_________ kustomization.yaml]]></ac:plain-text-body></ac:structured-macro><ac:structured-macro ac:name="info" ac:schema-version="1" ac:macro-id="c44aa8d3-5f3c-4b50-89f1-258aafdeeade"><ac:rich-text-body><p>App repo: <a href="https://bitbucket.org/getirdev/kustomize-base-manifests/src/poc-helm-centralized-repo/test-microservice/overlays/prod/" data-card-appearance="inline">https://bitbucket.org/getirdev/kustomize-base-manifests/src/poc-helm-centralized-repo/test-microservice/overlays/prod/</a> (Patch not being applied)</p></ac:rich-text-body></ac:structured-macro><p>There are issues with using the helmchartInflationGenerator from kustomize. I m analyzing this option further to see how I could make it work in the best possible fashion</p><p>Current problems</p><ul><li><p>kustomize supports helm charts to be deployed. but the patch is not being applied</p></li><li><p>The CD pipeline can be a bit complicated to use both together (Requirs templating from the helm and then using them to apply the patch)</p></li><li><p>use of multiple value files is not supported</p></li><li><p>Unsure about the support of sops (helm secrets plugin can be passed to the kustomize command <code>kustomize build --helm-command /opt/homebrew/bin/helm secrets --enable-helm</code> </p></li></ul><p>Another approach here would be to use the helm template first and then apply kustomize on the generated template. (Only reading examples knowledge) with the similar proposed structure</p><ac:structured-macro ac:name="code" ac:schema-version="1" ac:macro-id="b8f47acc-d9c9-4563-847f-bcc4a52bcb5b"><ac:plain-text-body><![CDATA[helm template base_chart >> basechart.yaml
k kustomize build overlays/dev (this should refernce to the basechart.yaml generated)]]></ac:plain-text-body></ac:structured-macro><h3>Monorepo</h3><p>The base manifests and the application manifests can reside in a single repository, which would mean that the access to the base would be using relative paths. This can also help in using helm and kustomize according to the application&rsquo;s needs. (I haven't tested this, but theoretically, I cannot see any reasons that it wouldn't work)</p><p>Proposed structure</p><ac:structured-macro ac:name="code" ac:schema-version="1" ac:macro-id="42fbbdaf-c25f-41b6-98c1-39ae016d2339"><ac:plain-text-body><![CDATA[BASE REPOSITORY

|__Helm_template_repository
|____ Chart.yaml
|____ values.default.yaml
|____ templates
|_______ deployment.yaml
|_______ hpa.yaml
|_______ service.yaml
|
|
|Kustomize_template_repository
|__ base
|_______ deployment.yaml
|_______ service.yaml
|___overlays
|_______ overlay_with_hpa
|_________ hpa.yaml
|_________ kustomization.yaml
|_______ overlay_with_cronjob
|_________ cronjob.yaml
|_________ kustomization.yaml
|_______ overlay_with_ingress
|_________ ingress.yaml
|_________ kustomization.yaml
|
|
|app1_kustomize_repository
|____ overlays
|______ dev
|_________ deployment-patch.yaml
|_________ kustomization.yaml
|______ prod
|_________ deployment-patch.yaml
|_________ hpa-patch.yaml
|_________ kustomization.yaml
|
|
|__app2_helm_repository
|____ Chart.yaml 
|____ values.default.override.yaml
|____ dev
|_______ values.dev.yaml
|_______ secrets.dev.yaml
|____ prod
|_______ values.prod.yaml
|_______ secrets.prod.yaml]]></ac:plain-text-body></ac:structured-macro><ac:structured-macro ac:name="info" ac:schema-version="1" ac:macro-id="d7b531b8-cea8-4d66-ae4b-52a7e1b71ede"><ac:rich-text-body><p>The example already has the microservice residing in the same repo and has been tested with relative paths</p></ac:rich-text-body></ac:structured-macro><table data-layout="default" ac:local-id="4958e0f9-e5ae-4340-85ac-10b701645530"><tbody><tr><th><p><strong>Pros</strong></p></th><th><p><strong>Cons</strong></p></th></tr><tr><td><p>Only relative paths</p></td><td><p>All manifests should be migrated to a single repo</p></td></tr><tr><td><p>Everything in a single place ??</p></td><td><p>RBAC wouldnt be possible and no separation per tribe</p></td></tr><tr><td><p /></td><td><p>A single source of truth for all microservices increases the risk of someone accidentally making changes to apps that were not meant</p></td></tr><tr><td><p /></td><td><p>Repo would be huge and the CD will have to clone it for every deployment (Depends on the CI/CD setup though)</p></td></tr></tbody></table><h2>Timeline:</h2><p><em>1 month for the creation of centralized manifest repo (Helm based)</em></p><p>1-2 months for adapting the existing manifest repos (Easier would be to keep both in parallel and make the switch gradually)</p><p>1 month of testing and improving</p><h2>Dependencies:</h2><p><em>The current workflow heavily relies on Kustomize and the patches are more or less equivalent to the whole base in some cases. Depends on the CI/CD workflow as well. Including secret management</em></p><h2>Alternatives Considered/Prior Art:</h2><p><em>All the approaches that are considered are documented. </em></p><p>Another approach would be to remain in the same setup. </p><h2>Operations:</h2><p><em>This would require additional effort on developers as they will have to adapt their kustomization.yaml according to the new approach. If using helm, the CD pipeline will have to be adapted. </em></p><p>The following are the identified tasks that have to be done and possible automation:</p><p><strong>Helm approach</strong></p><ol start="1"><li><p>Creation of centralized manifest repo: to be performed by the <strong>EED team</strong> taking into consideration all the manifests that are being used in all deployments. Create the CI to push the helm chart to be pushed to ECR or any Helm registry of our choice. </p></li><li><p>Updating the application manifest repo with the skeleton proposed in the RFC. This can be <strong>automated using kitchen templates</strong> or any other automation. </p></li><li><p>Updating values.yaml for each environment. This should be done by the <strong>developers</strong>, as they have ownership of the application values. </p></li><li><p>Update on the CI/CD to use helm upgrade instead of kustomize. </p></li></ol><p><strong>Kustomize approach</strong></p><ol start="1"><li><p>Creation of centralized manifest repo: to be performed by the <strong>EED team</strong> taking into consideration all the manifests that are being used in all deployments and writing overlays accordingly.</p></li><li><p>Updating the application manifest repo, to use the new base and different resources as overlays. This might <strong>not be automated</strong> as the resources and overlays can differ for each application. This would be on <strong>developers</strong>. </p></li></ol><h2>Security/Privacy/Compliance:</h2><p><em>What security/privacy/compliance aspects should be considered?</em></p><p><em>The security concern would be the storing of credentials to connect to a private helm repo (especially when using Spinnaker)</em></p><h2>Risks:</h2><p><em>What known risks exist? What factors may complicate your project?</em></p><table data-layout="default" ac:local-id="d7bce968-b1c9-4f73-b3a2-d370424c38be"><tbody><tr><th><p><strong>Helm approach</strong></p></th><th><p><strong>Kustomize</strong></p></th><th><p><strong>Helm + Kustomize</strong></p></th></tr><tr><td><p>New technology for org</p></td><td><p>Doesnt address the issue we are trying to tackle</p></td><td><p>Lack of team expertise</p></td></tr><tr><td><p>Security</p></td><td><p>Lack of team expertise</p></td><td><p>Service immaturity</p></td></tr><tr><td><p /></td><td><p>Compatibility</p></td><td><p>Compatibility</p></td></tr><tr><td><p /></td><td><p>Complex if we want to use transformers or anything fancy that kustomize offers to customize anything and everything (Very personal opinion)</p></td><td><p>High complexity</p></td></tr></tbody></table><p><em>Include security, complexity, compatibility, latency, service immaturity, lack of team expertise, etc.</em></p><h2>Revisions:</h2><ol start="1"><li><p><em>RFC Created</em></p></li><li><p><em>Update for major changes, including status changes.</em></p></li></ol><h2>Open Questions</h2><ol start="1"><li><p>What feature of kustomize are we using that cannot be fulfilled via Helm? </p></li><li><p>If we can&rsquo;t use Kustomize because developers still need to update the API version in the overlay, don&rsquo;t they also need to update the chart version with Helm?</p></li></ol><h2>Comments</h2><p>This a consolidation of the comments and a tl:dr; for everyone <ac:emoticon ac:name="smile" ac:emoji-shortname=":slight_smile:" ac:emoji-id="1f642" ac:emoji-fallback="ðŸ™‚" /> </p><ol start="1"><li><p>Why did I write the RFC on Confluence?</p><ol start="1"><li><p>I did not want the overhead of writing markdown</p></li><li><p>I do not like the commenting on the Pull request</p></li><li><p>If I want to contribute to someone&rsquo;s doc, I have to go through a git checkout, git push</p></li><li><p>Visually I find Confluence more appealing than reading a markdown file on a Bitbucket PR</p></li><li><p>Comments can be edited on Bitbucket as well.</p></li><li><p>There are other RFCs written on Confluence and they all look good <ac:emoticon ac:name="smile" ac:emoji-shortname=":slight_smile:" ac:emoji-id="1f642" ac:emoji-fallback="ðŸ™‚" /> </p></li><li><p>I have the Slack plugin to inform me of any comments that are posted in this doc and I can reply directly <ac:emoticon ac:name="blue-star" ac:emoji-shortname=":smiley:" ac:emoji-id="1f603" ac:emoji-fallback="ðŸ˜ƒ" /> </p></li></ol></li><li><p>With Helm can someone override templates?</p><ol start="1"><li><p>The helm chart is an aggregation of all the templates that we want. When a microservice is using a helm chart as a dependency, it can have its own template folder along with the chart dependency. One can have the default deployment template that comes from the base chart and have your own deployment on the template folder in the app manifest repo. Since we write our own base charts, we can always make any manifest not to be deployed. (Magic of helm templating and using values)</p></li><li><p>You can have multiple chart dependencies, multiple value files, override values that are specified in the default values file, and even have no value files</p></li></ol></li><li><p>How does the chart version work?</p><ol start="1"><li><p>We push the base chart to a registry (In the example here, I have pushed my base helm chart to <a href="https://eu-west-1.console.aws.amazon.com/ecr/repositories/private/289722705324/getir-app?region=eu-west-1">ECR</a>)</p></li><li><p>In the app manifest, we have to specify the Chart version to be used. This can be automated using the CI. (I personally do not like this automation as there can be breaking changes in the manifests and devs should acknowledge the changes)</p></li></ol></li><li><p>How can we change the HPA version?</p><ol start="1"><li><p>In case of using helm templates, the base is the place where this should be updated. If there are devs having their own templates in the manifest repo, they should handle it themselves. When the base is updated, this also requires the devs to update their manifest repo to the newly released version of the Chart and make changes according to the Changelog (Only relevant for any breaking changes)</p></li><li><p>In case of kustomize, the base has to be updated but also the overlays as it would be referencing the API version again. </p></li></ol></li><li><p>Avoid using both together - had many likes</p><ol start="1"><li><p>I have seen this approach being used on multiple projects. It is complicated. But helps us leverage the benefit of both. </p></li><li><p>I personally do not have enough kustomize expertise to make this work in the best possible fashion</p></li></ol></li><li><p>What would the update look like?</p><ol start="1"><li><p>If using helm, we will use Kitchen to create the Chart repo in all manifest repos with basic values.yaml files. The devs will have to adapt the values.yaml according to their needs. </p></li><li><p>If using kustomize, the only change would be the change of bases that they wanna use. I wouldn't personally recommend a Kitchen template for this, but we could of course update it with any automation</p></li></ol></li><li><p>What security issue do we have with Helm?</p><ol start="1"><li><p>The helm chart registry has to be authenticated in order to pull the charts. Git as a source is not supported atm. The ECR registry credentials have to be rotated using a cronjob similar to ecr-cred-helper in ArgoCD for instance.</p></li></ol></li><li><p>Why would Kustomize centralized repo not solve the issue?</p><ol start="1"><li><p>Kustomize overlays would have the API versions mentioned again. So there would be the need of adapting the overlays as well in case of a version change (Please correct me if I understood the overlays wrong)</p></li></ol></li><li><p>What compatibility issue do we have with kustomize?</p><ol start="1"><li><p>Using vars is not very easy for me in kustomize</p></li><li><p>As the dev, you would need to know the metadata in the base to write the overlay. </p></li></ol></li><li><p>Feel free to add your questions here or in the section above</p></li></ol><ac:structured-macro ac:name="toc" ac:schema-version="1" data-layout="default" ac:local-id="0f57e361-eac2-42ac-b24e-836c778e2c3b" ac:macro-id="433237cf-83f8-454a-964f-05612255ec2c" /><h1>heading1</h1><p>sdfsdfjsjfk</p><h1>heading12</h1><p>This is a sample Confluence page </p><p>checking table</p><ul><li><p>list1<br />something under the list<br />sefseejhfjsfhs</p></li><li><p>list2<br />again under the list<br />Sfjhbwjhkjfwfbjfsfkjsnfkj sfhugw eswkh weuzghfe fkwjhfuesf gk fwuhwl euhs fksuhjh kweufg khwh</p></li></ul><blockquote><p>hello from quotes<br />multiline quotes</p></blockquote><p><time datetime="2023-07-18" /> is today</p><h2>heading2</h2><p>this is a heading 2 content</p><ac:structured-macro ac:name="info" ac:schema-version="1" ac:macro-id="1136c904-9d16-40eb-b9c8-dc23e8336915"><ac:rich-text-body><p>This is an info panel<br />multi <strong>line</strong></p></ac:rich-text-body></ac:structured-macro><h3>heading3</h3><p>this is a heading 3 <strong>content that is bold</strong></p><ol start="1"><li><p>another list<br />ndfkjsdfksjnf</p></li><li><p>numbered list 2<br />SFSFSDG<br />sddgdg</p></li></ol><p>Here is a table</p><table data-layout="default" ac:local-id="5dd21c9f-a3b7-40c2-908a-327c9f32b835"><tbody><tr><th><p><strong>sfsfs</strong></p></th><th><p><strong>sdfsdfs</strong></p></th><th><p><strong>sdfss</strong></p></th></tr><tr><td><p>dgsd</p></td><td><p>sgsdg</p></td><td><p>sdgsg</p></td></tr><tr><td><p>sdgs</p></td><td><p>ssdsdg</p></td><td><p>sdgsdgsdg</p></td></tr></tbody></table><p><em>some italics</em></p><p>Adding some code as well</p><ac:structured-macro ac:name="code" ac:schema-version="1" ac:macro-id="fd388cbf-6ef6-42c6-9013-febf7cd915ab"><ac:plain-text-body><![CDATA[this is a code snippet
type Content struct {
	Title string `json:"title"`
	Body  Body   `json:"body"`
}]]></ac:plain-text-body></ac:structured-macro><p><a href="https://github.com/JohannesKaufmann/html-to-markdown/blob/2273319a237d17ccb70f2ea0cb1f1934c96c190c/commonmark.go">something</a> </p><p><ac:link><ri:page ri:content-title="Getting started in Confluence" ri:version-at-save="1" /><ac:link-body>hello world</ac:link-body></ac:link></p><p><ac:link><ri:page ri:space-key="TS" ri:content-title="page test space 1" ri:version-at-save="1" /><ac:link-body>another link</ac:link-body></ac:link></p><ac:structured-macro ac:name="toc" ac:schema-version="1" data-layout="default" ac:local-id="0f57e361-eac2-42ac-b24e-836c778e2c3b" ac:macro-id="433237cf-83f8-454a-964f-05612255ec2c" /><h1>heading1</h1><p>sdfsdfjsjfk</p><h1>heading12</h1><p>This is a sample Confluence page </p><p>checking table</p><ul><li><p>list1<br />something under the list<br />sefseejhfjsfhs</p></li><li><p>list2<br />again under the list<br />Sfjhbwjhkjfwfbjfsfkjsnfkj sfhugw eswkh weuzghfe fkwjhfuesf gk fwuhwl euhs fksuhjh kweufg khwh</p></li></ul><blockquote><p>hello from quotes<br />multiline quotes</p></blockquote><p><time datetime="2023-07-18" /> is today</p><h2>heading2</h2><p>this is a heading 2 content</p><ac:structured-macro ac:name="info" ac:schema-version="1" ac:macro-id="1136c904-9d16-40eb-b9c8-dc23e8336915"><ac:rich-text-body><p>This is an info panel<br />multi <strong>line</strong></p></ac:rich-text-body></ac:structured-macro><h3>heading3</h3><p>this is a heading 3 <strong>content that is bold</strong></p><ol start="1"><li><p>another list<br />ndfkjsdfksjnf</p></li><li><p>numbered list 2<br />SFSFSDG<br />sddgdg</p></li></ol><p>Here is a table</p><table data-layout="default" ac:local-id="5dd21c9f-a3b7-40c2-908a-327c9f32b835"><tbody><tr><th><p><strong>sfsfs</strong></p></th><th><p><strong>sdfsdfs</strong></p></th><th><p><strong>sdfss</strong></p></th></tr><tr><td><p>dgsd</p></td><td><p>sgsdg</p></td><td><p>sdgsg</p></td></tr><tr><td><p>sdgs</p></td><td><p>ssdsdg</p></td><td><p>sdgsdgsdg</p></td></tr></tbody></table><p><em>some italics</em></p><p>Adding some code as well</p><ac:structured-macro ac:name="code" ac:schema-version="1" ac:macro-id="fd388cbf-6ef6-42c6-9013-febf7cd915ab"><ac:plain-text-body><![CDATA[this is a code snippet
type Content struct {
	Title string `json:"title"`
	Body  Body   `json:"body"`
}]]></ac:plain-text-body></ac:structured-macro><p><a href="https://github.com/JohannesKaufmann/html-to-markdown/blob/2273319a237d17ccb70f2ea0cb1f1934c96c190c/commonmark.go">something</a> </p><p><ac:link><ri:page ri:content-title="Getting started in Confluence" ri:version-at-save="1" /><ac:link-body>hello world</ac:link-body></ac:link></p><p><ac:link><ri:page ri:space-key="TS" ri:content-title="page test space 1" ri:version-at-save="1" /><ac:link-body>another link</ac:link-body></ac:link></p><ac:structured-macro ac:name="toc" ac:schema-version="1" data-layout="default" ac:local-id="0f57e361-eac2-42ac-b24e-836c778e2c3b" ac:macro-id="433237cf-83f8-454a-964f-05612255ec2c" /><h1>heading1</h1><p>sdfsdfjsjfk</p><h1>heading12</h1><p>This is a sample Confluence page </p><p>checking table</p><ul><li><p>list1<br />something under the list<br />sefseejhfjsfhs</p></li><li><p>list2<br />again under the list<br />Sfjhbwjhkjfwfbjfsfkjsnfkj sfhugw eswkh weuzghfe fkwjhfuesf gk fwuhwl euhs fksuhjh kweufg khwh</p></li></ul><blockquote><p>hello from quotes<br />multiline quotes</p></blockquote><p><time datetime="2023-07-18" /> is today</p><h2>heading2</h2><p>this is a heading 2 content</p><ac:structured-macro ac:name="info" ac:schema-version="1" ac:macro-id="1136c904-9d16-40eb-b9c8-dc23e8336915"><ac:rich-text-body><p>This is an info panel<br />multi <strong>line</strong></p></ac:rich-text-body></ac:structured-macro><h3>heading3</h3><p>this is a heading 3 <strong>content that is bold</strong></p><ol start="1"><li><p>another list<br />ndfkjsdfksjnf</p></li><li><p>numbered list 2<br />SFSFSDG<br />sddgdg</p></li></ol><p>Here is a table</p><table data-layout="default" ac:local-id="5dd21c9f-a3b7-40c2-908a-327c9f32b835"><tbody><tr><th><p><strong>sfsfs</strong></p></th><th><p><strong>sdfsdfs</strong></p></th><th><p><strong>sdfss</strong></p></th></tr><tr><td><p>dgsd</p></td><td><p>sgsdg</p></td><td><p>sdgsg</p></td></tr><tr><td><p>sdgs</p></td><td><p>ssdsdg</p></td><td><p>sdgsdgsdg</p></td></tr></tbody></table><p><em>some italics</em></p><p>Adding some code as well</p><ac:structured-macro ac:name="code" ac:schema-version="1" ac:macro-id="fd388cbf-6ef6-42c6-9013-febf7cd915ab"><ac:plain-text-body><![CDATA[this is a code snippet
type Content struct {
	Title string `json:"title"`
	Body  Body   `json:"body"`
}]]></ac:plain-text-body></ac:structured-macro><p><a href="https://github.com/JohannesKaufmann/html-to-markdown/blob/2273319a237d17ccb70f2ea0cb1f1934c96c190c/commonmark.go">something</a> </p><p><ac:link><ri:page ri:content-title="Getting started in Confluence" ri:version-at-save="1" /><ac:link-body>hello world</ac:link-body></ac:link></p><p><ac:link><ri:page ri:space-key="TS" ri:content-title="page test space 1" ri:version-at-save="1" /><ac:link-body>another link</ac:link-body></ac:link></p>